import numpy as np
import pandas as pd
from scipy.integrate import cumulative_trapezoid
import matplotlib.pyplot as plt

# -------------------- 1. Physical Constants and Simulation Parameters --------------------

# Convert LAMMPS units ('metal' units) to SI for final kappa result (W/m-K)
EV_TO_J = 1.602176634e-19       # eV to J
A_TO_M = 1.0e-10               # Angstrom to m
PS_TO_S = 1.0e-12              # picosecond to second
KB = 1.380649e-23              # Boltzmann constant (J/K)

# Simulation parameters (MUST match the LAMMPS input file)
T = 300.0                      # Simulation Temperature (K)
V = 10.0*3 * A_TO_M*3        # Simulation Volume (10x10x10 Angstrom^3 converted to m^3)

# Green-Kubo Formula Constant (SI Units):
# kappa = (1 / 3 V k_B^2 T^2) * Integral_0^inf (<J(t).J(0)> dt)
GK_FACTOR = (1.0 / (3.0 * V * KB*2 * T*2))

# -------------------- 2. Load and Process Data --------------------

try:
    # Load the HFACF data file generated by LAMMPS
    df = pd.read_csv('hfacf.dat', sep='\s+', skiprows=4, header=None)
    
    # Extract the autocorrelation data (columns 3, 4, 5 are JxJx, JyJy, JzJz)
    JxJx = df.iloc[:, 2].values
    JyJy = df.iloc[:, 3].values
    JzJz = df.iloc[:, 4].values
    
    # Time vector
    time_ps = df.iloc[:, 1].values # Time in picoseconds (ps)
    time_array = time_ps * PS_TO_S # Time in seconds (s)
    
    print(f"Loaded HFACF data from 'hfacf.dat' with {len(time_ps)} points.")
    
except FileNotFoundError:
    print("\n--- WARNING: 'hfacf.dat' not found. Generating MOCK DATA for demonstration. ---")
    
    # --- MOCK DATA GENERATION (Simulates a typical HFACF decay) ---
    max_corr_time_ps = 50.0 # Simulate a longer correlation time
    time_ps = np.linspace(0, max_corr_time_ps, 500)
    time_array = time_ps * PS_TO_S
    
    # Simulate an exponential decay for J.J (eV^2/ps)
    initial_value = 1.5e-5
    decay_time = 5.0 # Decay time constant (in ps)
    
    # Add a small offset to simulate long-time tail issues (common in real data)
    offset = 1.0e-7
    HFACF_sum_raw = initial_value * np.exp(-time_ps / decay_time) + offset
    
    # Add some random high-frequency noise
    noise = 0.5e-7 * np.sin(time_ps * 15)
    HFACF_sum = HFACF_sum_raw + noise
    
    # Components (divide the sum)
    JxJx = HFACF_sum / 3
    JyJy = HFACF_sum / 3
    JzJz = HFACF_sum / 3

    print(f"Generated synthetic HFACF data for {max_corr_time_ps} ps.")
    
# Calculate the sum of the autocorrelation functions for the three components
# Units: eV^2 / ps
HFACF_sum = JxJx + JyJy + JzJz

# Convert the HFACF sum to SI units: J^2/s
HFACF_SI = HFACF_sum * (EV_TO_J**2 / PS_TO_S)

# -------------------- 3. Running Integral and Kappa Calculation --------------------

# Calculate the running integral (cumulative sum over time)
# This gives the integral value up to time t: Integral_0^t (<J(t').J(0)> dt')
running_integral = cumulative_trapezoid(HFACF_SI, time_array, initial=0)

# Calculate the running thermal conductivity (kappa(t)) in W/m-K
running_kappa = GK_FACTOR * running_integral

# The final thermal conductivity is the converged value at the end
final_integral = running_integral[-1]
final_kappa = running_kappa[-1]

# -------------------- 4. Output Results --------------------

print("\n--- Green-Kubo Thermal Conductivity Calculation Results ---")
print(f"Simulation Temperature (T): {T:.2f} K")
print(f"Simulation Volume (V): {V:.2e} m^3")
print(f"Maximum Correlation Time: {time_ps[-1]:.2f} ps")
print(f"Integrated HFACF Value (SI): {final_integral:.2e} J^2/s-K^2")
print(f"Final Thermal Conductivity (kappa): {final_kappa:.4f} W/m-K")
print("-----------------------------------------------------------------\n")

# -------------------- 5. Plotting the Results --------------------

fig, axes = plt.subplots(2, 1, figsize=(10, 8), sharex=True)
plt.suptitle('Thermal Conductivity Results via Green-Kubo Method', fontsize=14)

# --- Graph 1: Heat Flux Autocorrelation Function (HFACF) ---
axes[0].plot(time_ps, HFACF_sum, label=r'$\sum_{i=x,y,z} \langle J_i(t) J_i(0) \rangle$', color='C0')
axes[0].set_ylabel(r'HFACF ($\mathrm{eV^2/ps}$)', fontsize=12)
axes[0].axhline(0, color='gray', linestyle='--')
axes[0].grid(True, linestyle=':', alpha=0.6)
axes[0].legend()
axes[0].ticklabel_format(style='sci', axis='y', scilimits=(0,0))
axes[0].set_title('A) Heat Flux Autocorrelation Function (HFACF)', loc='left', fontsize=10)

# --- Graph 2: Running Integral / Thermal Conductivity Convergence ---
axes[1].plot(time_ps, running_kappa, label=r'$\kappa(t)$ Convergence', color='C1')
axes[1].axhline(final_kappa, color='red', linestyle='--', label=f'Final $\kappa$ = {final_kappa:.4f} W/m-K')
axes[1].set_xlabel('Time (ps)', fontsize=12)
axes[1].set_ylabel(r'$\kappa$ (W/m-K)', fontsize=12)
axes[1].grid(True, linestyle=':', alpha=0.6)
axes[1].legend()
axes[1].set_title('B) Running Integral of HFACF (Thermal Conductivity Convergence)', loc='left', fontsize=10)

plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # Adjust for suptitle
plt.show()
